---------------------------------------------------------------------
----
---- AUTOGENERATED FILE - DO NOT EDIT
---- DRM SCRIPT VERSION 2.1.0
---- DRM HDK VERSION 3.2.1.0
---- DRM VERSION 3.2.1
---- COPYRIGHT (C) ALGODONE
----
---------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library DRM_LIBRARY;
use DRM_LIBRARY.DRM_PACKAGE.all;
use DRM_LIBRARY.DRM_INTERFACES_PACKAGE.all;
use DRM_LIBRARY.LICENSE_MASTER_PUF_PACKAGE.all;
use DRM_LIBRARY.DRM_IP_COMPONENTS.all;

entity drm_controller_ip is
  generic (
    SYS_BUS_ADR_BEGIN       : natural := 0;
    SYS_BUS_ADR_SIZE        : natural := 16;
    SYS_BUS_DAT_SIZE        : natural := 32;
    READ_WRITE_MAILBOX_SIZE : natural := 16; -- read write mailbox size in number of 32 bits words
    READ_ONLY_MAILBOX_DATA  : std_logic_vector := x"6576227b726f646e22203a2265636361657a696c6d6f632e22202c22656d616e22203a225f626261685f31666f6c6c657566615f6c74725f22202c227262696c227972616722203a7568746965675f626e697474617473676465747222202c226e67697322203a2200007d22" -- read only mailbox data (left is the first read only mailbox word)
  );
  port (
    -- AXI4 LITE Slave clock and reset
    SYS_AXI4_ACLK                 : in  std_logic;
    SYS_AXI4_ARSTN                : in  std_logic;
    -- AXI4 LITE Slave address write channel
    SYS_AXI4_BUS_SLAVE_I_AW_VALID : in  std_logic;
    SYS_AXI4_BUS_SLAVE_I_AW_ADDR  : in  std_logic_vector(SYS_BUS_ADR_SIZE-1 downto 0);
    SYS_AXI4_BUS_SLAVE_I_AW_PROT  : in  std_logic_vector(2 downto 0);
    SYS_AXI4_BUS_SLAVE_O_AW_READY : out std_logic;
    -- AXI4 LITE Slave address read channel
    SYS_AXI4_BUS_SLAVE_I_AR_VALID : in  std_logic;
    SYS_AXI4_BUS_SLAVE_I_AR_ADDR  : in  std_logic_vector(SYS_BUS_ADR_SIZE-1 downto 0);
    SYS_AXI4_BUS_SLAVE_I_AR_PROT  : in  std_logic_vector(2 downto 0);
    SYS_AXI4_BUS_SLAVE_O_AR_READY : out std_logic;
    -- AXI4 LITE Slave data write channel
    SYS_AXI4_BUS_SLAVE_I_W_VALID  : in  std_logic;
    SYS_AXI4_BUS_SLAVE_I_W_DATA   : in  std_logic_vector(SYS_BUS_DAT_SIZE-1 downto 0);
    SYS_AXI4_BUS_SLAVE_I_W_STRB   : in  std_logic_vector(SYS_BUS_DAT_SIZE/8-1 downto 0);
    SYS_AXI4_BUS_SLAVE_O_W_READY  : out std_logic;
    -- AXI4 LITE Slave data read channel
    SYS_AXI4_BUS_SLAVE_I_R_READY  : in  std_logic;
    SYS_AXI4_BUS_SLAVE_O_R_VALID  : out std_logic;
    SYS_AXI4_BUS_SLAVE_O_R_DATA   : out std_logic_vector(SYS_BUS_DAT_SIZE-1 downto 0);
    SYS_AXI4_BUS_SLAVE_O_R_RESP   : out std_logic_vector(1 downto 0);
    -- AXI4 LITE Slave write response channel
    SYS_AXI4_BUS_SLAVE_I_B_READY  : in  std_logic;
    SYS_AXI4_BUS_SLAVE_O_B_VALID  : out std_logic;
    SYS_AXI4_BUS_SLAVE_O_B_RESP   : out std_logic_vector(1 downto 0);
    -- Chip dna bus
    CHIP_DNA_VALID                : out std_logic;
    CHIP_DNA                      : out std_logic_vector(63 downto 0);
    -- DRM Bus clock and reset
    DRM_ACLK                      : in  std_logic;
    DRM_ARSTN                     : in  std_logic;
    -- DRM Bus master common socket
    DRM_BUS_MASTER_O_CYC          : out std_logic;
    DRM_BUS_MASTER_O_WE           : out std_logic;
    DRM_BUS_MASTER_O_ADR          : out std_logic_vector(1 downto 0);
    DRM_BUS_MASTER_O_DAT          : out std_logic_vector(0 downto 0);
    -- DRM Bus master ip 0 socket
    DRM_BUS_MASTER_O_CS_0         : out std_logic;
    DRM_BUS_MASTER_I_ACK_0        : in  std_logic;
    DRM_BUS_MASTER_I_STA_0        : in  std_logic;
    DRM_BUS_MASTER_I_INTR_0       : in  std_logic;
    DRM_BUS_MASTER_I_DAT_0        : in  std_logic_vector(0 downto 0)
  );
end entity drm_controller_ip;

architecture drm_controller_ip_RTL of drm_controller_ip is

  -- slave selector type
  type T_SLAVE_SELECTOR is (
    SELECT_NONE,
    SELECT_DNA,
    SELECT_IP_0
  );

  -- drm slaves addresses
  constant C_DRM_DNA_ADR : std_logic_vector(C_DRM_BUS_ADR_SIZE-C_DRM_BUS_ADR_LSB_SIZE-1 downto 0) := std_logic_vector(to_unsigned(0, C_DRM_BUS_ADR_SIZE-C_DRM_BUS_ADR_LSB_SIZE));
  constant C_DRM_IP_ADR_0 : std_logic_vector(C_DRM_BUS_ADR_SIZE-C_DRM_BUS_ADR_LSB_SIZE-1 downto 0) := std_logic_vector(to_unsigned(1, C_DRM_BUS_ADR_SIZE-C_DRM_BUS_ADR_LSB_SIZE));

  -- internal signals
  signal S_DRM_BUS_MASTER_I_DAT  : std_logic_vector(C_DRM_BUS_DAT_SIZE-1 downto 0);
  signal S_DRM_BUS_MASTER_I_ACK  : std_logic;
  signal S_DRM_BUS_MASTER_I_INTR : std_logic;
  signal S_DRM_BUS_MASTER_I_STA  : std_logic_vector(0 downto 0);

  signal S_DRM_BUS_MASTER_O_CYC  : std_logic;
  signal S_DRM_BUS_MASTER_O_WE   : std_logic;
  signal S_DRM_BUS_MASTER_O_ADR  : std_logic_vector(C_DRM_BUS_ADR_SIZE-1 downto 0);
  signal S_DRM_BUS_MASTER_O_DAT  : std_logic_vector(C_DRM_BUS_DAT_SIZE-1 downto 0);

  signal S_DRM_BUS_SLAVE_I_CS    : std_logic;
  signal S_DRM_BUS_SLAVE_I_CYC   : std_logic;
  signal S_DRM_BUS_SLAVE_I_WE    : std_logic;
  signal S_DRM_BUS_SLAVE_I_ADR   : std_logic_vector(C_DRM_BUS_ADR_LSB_SIZE-1 downto 0);
  signal S_DRM_BUS_SLAVE_I_DAT   : std_logic_vector(C_DRM_BUS_DAT_SIZE-1 downto 0);

  signal S_DRM_BUS_SLAVE_O_DAT   : std_logic_vector(C_DRM_BUS_DAT_SIZE-1 downto 0);
  signal S_DRM_BUS_SLAVE_O_ACK   : std_logic;
  signal S_DRM_BUS_SLAVE_O_INTR  : std_logic;

  signal S_SPLITTED_DRM_BUS_MASTER_O_ADR : std_logic_vector(C_DRM_BUS_ADR_SIZE-C_DRM_BUS_ADR_LSB_SIZE-1 downto 0);

  signal S_SLAVE_SELECTOR : T_SLAVE_SELECTOR;

  signal S_DRM_ACLK  : std_logic;
  signal S_DRM_ARSTN : std_logic;

  constant C_drm_controller_ip_DRM_VERSION : std_logic_vector(23 downto 0) := x"030201";

begin

  -- drm controller version check
  assert C_drm_controller_ip_DRM_VERSION(23 downto 8) = C_DRM_MASTER_DRM_VERSION(23 downto 8)
    report "The version of the DRM Controller is not supported by the DRM HDK." severity failure;

  -- drm authenticator version check
  assert C_drm_controller_ip_DRM_VERSION(23 downto 8) = C_DRM_AUTHENTICATOR_DRM_VERSION(23 downto 8)
    report "The version of the DRM Authenticator is not supported by the DRM HDK." severity failure;

  S_DRM_ACLK  <= DRM_ACLK;
  S_DRM_ARSTN <= DRM_ARSTN;

  -- drm controller instantiation
  DRM_CONTROLLER_INSTANCE : DRM_CONTROLLER
    generic map (
      1,
      SYS_BUS_ADR_BEGIN,
      READ_WRITE_MAILBOX_SIZE,
      READ_ONLY_MAILBOX_DATA,
      SYS_BUS_ADR_SIZE,
      SYS_BUS_DAT_SIZE
    )
    port map (
      '1',
      '0',
      S_DRM_ACLK,
      S_DRM_ARSTN,
      S_DRM_BUS_MASTER_I_DAT,
      S_DRM_BUS_MASTER_I_ACK,
      S_DRM_BUS_MASTER_I_INTR,
      S_DRM_BUS_MASTER_I_STA,
      S_DRM_BUS_MASTER_O_CYC,
      S_DRM_BUS_MASTER_O_WE,
      S_DRM_BUS_MASTER_O_ADR,
      S_DRM_BUS_MASTER_O_DAT,
      SYS_AXI4_ACLK,
      SYS_AXI4_ARSTN,
      SYS_AXI4_BUS_SLAVE_I_AW_VALID,
      SYS_AXI4_BUS_SLAVE_I_AW_ADDR,
      SYS_AXI4_BUS_SLAVE_I_AW_PROT,
      SYS_AXI4_BUS_SLAVE_O_AW_READY,
      SYS_AXI4_BUS_SLAVE_I_AR_VALID,
      SYS_AXI4_BUS_SLAVE_I_AR_ADDR,
      SYS_AXI4_BUS_SLAVE_I_AR_PROT,
      SYS_AXI4_BUS_SLAVE_O_AR_READY,
      SYS_AXI4_BUS_SLAVE_I_W_VALID,
      SYS_AXI4_BUS_SLAVE_I_W_DATA,
      SYS_AXI4_BUS_SLAVE_I_W_STRB,
      SYS_AXI4_BUS_SLAVE_O_W_READY,
      SYS_AXI4_BUS_SLAVE_I_R_READY,
      SYS_AXI4_BUS_SLAVE_O_R_VALID,
      SYS_AXI4_BUS_SLAVE_O_R_DATA,
      SYS_AXI4_BUS_SLAVE_O_R_RESP,
      SYS_AXI4_BUS_SLAVE_I_B_READY,
      SYS_AXI4_BUS_SLAVE_O_B_VALID,
      SYS_AXI4_BUS_SLAVE_O_B_RESP
    );

  -- drm dna instantiation
  DRM_DNA_INSTANCE : DRM_DNA
    generic map (
      C_LICENSE_MASTER_PUF_RANDOM_ID_NAME
    )
    port map (
      S_DRM_BUS_SLAVE_I_CS,
      '0',
      S_DRM_ARSTN,
      S_DRM_ACLK,
      S_DRM_BUS_SLAVE_I_CYC,
      S_DRM_BUS_SLAVE_I_WE,
      S_DRM_BUS_SLAVE_I_ADR,
      S_DRM_BUS_SLAVE_I_DAT,
      S_DRM_BUS_SLAVE_O_DAT,
      S_DRM_BUS_SLAVE_O_ACK,
      S_DRM_BUS_SLAVE_O_INTR,
      CHIP_DNA_VALID,
      CHIP_DNA
    );

  -- drm bus slave status link
  S_DRM_BUS_MASTER_I_STA(0) <= DRM_BUS_MASTER_I_STA_0;

	-- drm bus slave address multiplexer
  S_SPLITTED_DRM_BUS_MASTER_O_ADR <= S_DRM_BUS_MASTER_O_ADR(C_DRM_BUS_ADR_SIZE-1 downto C_DRM_BUS_ADR_LSB_SIZE);
  P_SLAVE_SELECT : process(S_SPLITTED_DRM_BUS_MASTER_O_ADR)
  begin
    if S_SPLITTED_DRM_BUS_MASTER_O_ADR = C_DRM_DNA_ADR then
      S_SLAVE_SELECTOR <= SELECT_DNA;
    elsif S_SPLITTED_DRM_BUS_MASTER_O_ADR = C_DRM_IP_ADR_0 then
      S_SLAVE_SELECTOR <= SELECT_IP_0;
    else
      S_SLAVE_SELECTOR <= SELECT_NONE;
    end if;
  end process P_SLAVE_SELECT;

  -- input registers
  P_INPUT_REGISTERS : process(S_DRM_ARSTN, S_DRM_ACLK)
  begin
    if S_DRM_ARSTN = '0' then
      S_DRM_BUS_MASTER_I_DAT <= (others => '0');
      S_DRM_BUS_MASTER_I_ACK <= '0';
      S_DRM_BUS_MASTER_I_INTR <= '0';
    elsif rising_edge(S_DRM_ACLK) then
      S_DRM_BUS_MASTER_I_DAT <= (others => '0');
      S_DRM_BUS_MASTER_I_ACK <= '0';
      S_DRM_BUS_MASTER_I_INTR <= '0';
      case S_SLAVE_SELECTOR is
        when SELECT_DNA =>
          S_DRM_BUS_MASTER_I_DAT <= S_DRM_BUS_SLAVE_O_DAT;
          S_DRM_BUS_MASTER_I_ACK <= S_DRM_BUS_SLAVE_O_ACK;
          S_DRM_BUS_MASTER_I_INTR <= S_DRM_BUS_SLAVE_O_INTR;
        when SELECT_IP_0 =>
          S_DRM_BUS_MASTER_I_DAT <= DRM_BUS_MASTER_I_DAT_0;
          S_DRM_BUS_MASTER_I_ACK <= DRM_BUS_MASTER_I_ACK_0;
          S_DRM_BUS_MASTER_I_INTR <= DRM_BUS_MASTER_I_INTR_0;
        when others =>
          S_DRM_BUS_MASTER_I_DAT <= (others => '0');
          S_DRM_BUS_MASTER_I_ACK <= '0';
          S_DRM_BUS_MASTER_I_INTR <= '0';
      end case;
    end if;
  end process P_INPUT_REGISTERS;

  -- output registers
  P_OUTPUT_REGISTERS : process(S_DRM_ARSTN, S_DRM_ACLK)
  begin
    if S_DRM_ARSTN = '0' then
      S_DRM_BUS_SLAVE_I_CS <= '0';
      S_DRM_BUS_SLAVE_I_CYC <= '0';
      S_DRM_BUS_SLAVE_I_WE <= '0';
      S_DRM_BUS_SLAVE_I_ADR <= (others => '0');
      S_DRM_BUS_SLAVE_I_DAT <= (others => '0');
      DRM_BUS_MASTER_O_CYC <= '0';
      DRM_BUS_MASTER_O_WE <= '0';
      DRM_BUS_MASTER_O_ADR <= (others => '0');
      DRM_BUS_MASTER_O_DAT <= (others => '0');
      DRM_BUS_MASTER_O_CS_0 <= '0';
    elsif rising_edge(S_DRM_ACLK) then
      S_DRM_BUS_SLAVE_I_CS <= '0';
      S_DRM_BUS_SLAVE_I_CYC <= '0';
      S_DRM_BUS_SLAVE_I_WE <= '0';
      S_DRM_BUS_SLAVE_I_ADR <= (others => '0');
      S_DRM_BUS_SLAVE_I_DAT <= (others => '0');
      DRM_BUS_MASTER_O_CYC <= '0';
      DRM_BUS_MASTER_O_WE <= '0';
      DRM_BUS_MASTER_O_ADR <= (others => '0');
      DRM_BUS_MASTER_O_DAT <= (others => '0');
      DRM_BUS_MASTER_O_CS_0 <= '0';
      case S_SLAVE_SELECTOR is
        when SELECT_DNA =>
          S_DRM_BUS_SLAVE_I_CS <= '1';
          S_DRM_BUS_SLAVE_I_CYC <= S_DRM_BUS_MASTER_O_CYC;
          S_DRM_BUS_SLAVE_I_WE <= S_DRM_BUS_MASTER_O_WE;
          S_DRM_BUS_SLAVE_I_ADR <= S_DRM_BUS_MASTER_O_ADR(C_DRM_BUS_ADR_LSB_SIZE-1 downto 0);
          S_DRM_BUS_SLAVE_I_DAT <= S_DRM_BUS_MASTER_O_DAT;
        when SELECT_IP_0 =>
          DRM_BUS_MASTER_O_CS_0 <= '1';
          DRM_BUS_MASTER_O_CYC <= S_DRM_BUS_MASTER_O_CYC;
          DRM_BUS_MASTER_O_WE <= S_DRM_BUS_MASTER_O_WE;
          DRM_BUS_MASTER_O_ADR <= S_DRM_BUS_MASTER_O_ADR(C_DRM_BUS_ADR_LSB_SIZE-1 downto 0);
          DRM_BUS_MASTER_O_DAT <= S_DRM_BUS_MASTER_O_DAT;
        when others =>
          S_DRM_BUS_SLAVE_I_CS <= '0';
          S_DRM_BUS_SLAVE_I_CYC <= '0';
          S_DRM_BUS_SLAVE_I_WE <= '0';
          S_DRM_BUS_SLAVE_I_ADR <= (others => '0');
          S_DRM_BUS_SLAVE_I_DAT <= (others => '0');
          DRM_BUS_MASTER_O_CYC <= '0';
          DRM_BUS_MASTER_O_WE <= '0';
          DRM_BUS_MASTER_O_ADR <= (others => '0');
          DRM_BUS_MASTER_O_DAT <= (others => '0');
          DRM_BUS_MASTER_O_CS_0 <= '0';
      end case;
    end if;
  end process P_OUTPUT_REGISTERS;

end architecture drm_controller_ip_RTL;
